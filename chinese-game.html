<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>注音符號節奏遊戲</title>
    <style>
        /* CSS 樣式維持原樣，此處省略以節省篇幅 */
        :root { --theme-color-1: #ff8c00; --font-family: 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', sans-serif; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: var(--font-family); overflow: hidden; touch-action: manipulation; background: linear-gradient(135deg, #2a2a3e, #4a3a4a); color: white; user-select: none; -webkit-user-select: none; }
        .game-ui-container.active { display: block; }
        .game-stats { display: flex; position: fixed; top: 20px; left: 20px; right: 20px; z-index: 50; justify-content: space-between; font-size: 1.5rem; color: white; text-shadow: 2px 2px 4px black; }
        canvas { position: absolute; top:0; left: 0; width: 100%; height: 100%; }
        /* 為了簡潔，省略了其他樣式，請保留您原有的完整 CSS */
    </style>
</head>
<body>
    <div id="game-container">
        <div class="game-stats"><span>分數: <span id="score">0</span></span><span>連擊: <span id="combo">0</span></span></div>
        <div id="timebeat-game-area" class="game-ui-container active"><canvas id="timebeat-canvas"></canvas></div>
    </div>
    <audio id="game-audio" preload="auto"></audio>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- 遊戲資料與模組定義 ---
        const SongData = {
            bopomofo_cat: {
                title: '注音練習：貓', artist: '國語作業', audioSrc: 'audio/cat_song.mp3', 
                beatmap: [ // ★ 將譜面資料直接放入，不再外部讀取
                    { "time": 1000, "type": "tap", "symbol": "ㄇ", "track": 0 },
                    { "time": 1500, "type": "tap", "symbol": "ㄠ", "track": 1 },
                    { "time": 2000, "type": "tap", "symbol": "ˊ", "track": 2 }
                ]
            }
        };
        const keyMap = { 'b': 'ㄅ', 'p': 'ㄆ', 'm': 'ㄇ', 'f': 'ㄈ', 'd': 'ㄉ', 't': 'ㄊ', 'n': 'ㄋ', 'l': 'ㄌ', 'g': 'ㄍ', 'k': 'ㄎ', 'h': 'ㄏ', 'j': 'ㄐ', 'q': 'ㄑ', 'x': 'ㄒ', 'z': 'ㄓ', 'c': 'ㄔ', 's': 'ㄕ', 'r': 'ㄖ', 'y': 'ㄗ', 'w': 'ㄘ', 'e': 'ㄙ', 'a': 'ㄚ', 'o': 'ㄛ', 'i': 'ㄧ', 'u': 'ㄨ', 'v': 'ㄩ', 'e': 'ㄜ', '2': 'ˊ', '3': 'ˇ', '4': 'ˋ', '5': '˙' };
        const symbolToTrack = {};
        Object.values(keyMap).forEach(symbol => {
            if ('ㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙ'.includes(symbol)) symbolToTrack[symbol] = 0;
            else if ('ㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ'.includes(symbol)) symbolToTrack[symbol] = 1;
            else if ('ˊˇˋ˙'.includes(symbol)) symbolToTrack[symbol] = 2;
        });

        // --- 遊戲核心控制器 (已修改) ---
        const Game = {
            state: { score: 0, combo: 0, isPlaying: false, startTime: 0, notesLeft: 0 },
            dom: {},
            init() {
                this.dom.canvas = document.getElementById('timebeat-canvas');
                this.dom.ctx = this.dom.canvas.getContext('2d');
                this.dom.scoreEl = document.getElementById('score');
                this.dom.comboEl = document.getElementById('combo');
                this.dom.gameAudio = document.getElementById('game-audio');
                window.addEventListener('resize', this.resize.bind(this));
                window.addEventListener('keydown', this.handleInput.bind(this));
                this.resize();
            },
            resize() { this.dom.canvas.width = window.innerWidth; this.dom.canvas.height = window.innerHeight; },
            startGame() {
                const song = SongData.bopomofo_cat;
                this.state = { ...this.state, score: 0, combo: 0, isPlaying: true, notes: [], beatmap: song.beatmap, nextNoteIndex: 0, notesLeft: song.beatmap.length };
                this.dom.gameAudio.src = song.audioSrc;
                this.dom.gameAudio.play().catch(e => console.error("Audio play failed:", e));
                this.state.startTime = performance.now();
                this.gameLoop();
            },
            gameLoop() {
                if (!this.state.isPlaying) return;
                const elapsedTime = performance.now() - this.state.startTime;
                this.update(elapsedTime);
                this.draw();
                requestAnimationFrame(this.gameLoop.bind(this));
            },
            update(elapsedTime) {
                while (this.state.nextNoteIndex < this.state.beatmap.length && this.state.beatmap[this.state.nextNoteIndex].time < elapsedTime + 2000) {
                    this.state.notes.push({ ...this.state.beatmap[this.state.nextNoteIndex], y: 0, active: true });
                    this.state.nextNoteIndex++;
                }
                const hitLineY = this.dom.canvas.height * 0.85;
                this.state.notes.forEach(note => {
                    if (note.active) {
                        const timeDiff = note.time - elapsedTime;
                        note.y = hitLineY - (timeDiff * 0.8);
                        if (timeDiff < -150) { // Miss
                            note.active = false;
                            this.updateCombo(false);
                            this.noteFinished();
                        }
                    }
                });
                this.state.notes = this.state.notes.filter(n => n.active);
            },
            draw() { /* ... draw 函式維持原樣 ... */ },
            handleInput(e) {
                if (!this.state.isPlaying) return;
                const inputSymbol = keyMap[e.key.toLowerCase()];
                if (!inputSymbol) return;
                const targetTrack = symbolToTrack[inputSymbol];
                const elapsedTime = performance.now() - this.state.startTime;
                
                const noteToHit = this.state.notes.find(n => n.active && n.track === targetTrack && Math.abs(n.time - elapsedTime) < 150);
                if (noteToHit) {
                    noteToHit.active = false;
                    this.updateCombo(true);
                    this.noteFinished();
                }
            },
            updateCombo(isHit) { /* ... updateCombo 函式維持原樣 ... */ },
            noteFinished() {
                this.state.notesLeft--;
                if (this.state.notesLeft === 0) {
                    this.endGame();
                }
            },
            endGame() {
                if (!this.state.isPlaying) return;
                this.state.isPlaying = false;
                this.dom.gameAudio.pause();
                setTimeout(() => { // 延遲一下確保玩家看到最後結果
                    alert(`國語作業完成！`);
                    parent.postMessage('chinese-game-complete', '*');
                }, 500);
            }
        };
        Game.init();
        Game.startGame();
    });
    </script>
</body>
</html>